---
title: State
keywords: 'useState, state management, reactivity, reactive'
contributors:
  - nnelgxorz
  - the-r3aper7
  - voluntadpear
  - kawamataryo
  - JaymanW
  - RATIU5
  - manucorporat
  - literalpie
  - fum4
  - cunzaizhuyi
  - zanettin
  - ChristianAnagnostou
  - shairez
  - forresst
  - almilo
  - Craiqser
  - XiaoChengyin
  - gkatsanos
  - adamdbradley
  - mhevery
  - un33k
---

import CodeSandbox from '../../../../../components/code-sandbox/index.tsx';

# State

State management is an important part of any app. In Qwik, we can differentiate between two types of state, reactive and static:

- Static state is anything that can be serialized: a string, number, object, array... anything.
- A reactive state on the other hand is created with `useSignal()` or `useStore()`.

It is important to notice that state in Qwik is not necessarily a local component state, but rather an app state that can be instantiated by any component.

State management is essential in any application. The Qwik framework categorizes state into two main types: `static` and `reactive`.

- `Static state` represents a snapshot of any serializable data captured at a specific moment in time.
  - Serializable data consists of strings, numbers, objects, arrays, and more.
  - This state can be paused by the server, transmitted to, and resumed by the browser.
  - Any non-serializable data must be set to `undefined`, with the responsibility of proper initialization handed over to the client once the state is resumed and the specific component becomes visible (hint: use useVisibleTask()).
- `Reactive state`, in contrast, can change at any given time.
  - Reactive state is created using the `useSignal()` or `useStore()` functions, (aka hooks).
  - These functions must be declared within components.
  - Reactive states are not confined to the component that generated them, as they can be shared among other components across the application.
  - Reactive states can be passed down via `props` or distributed throughout the application via `context`.
  - Any and all components that depend on a reactive state will be automatically updated when the state changes.

## `useSignal()`

The `useSignal()` function accepts an `initial value`, creates, and returns a `reactive state`, also known as a `signal`. This signal is an object with a single property, `.value`. Multiple components can consume the signal. When any component with access to the signal modifies the `.value` property, all dependent components will automatically update in response to the change.

<CodeSandbox src="/src/routes/demo/state/counter-signal/index.tsx" style={{ height: '6em' }}>
```tsx {4} /count/
import { component$, useSignal } from '@builder.io/qwik';

export default component$(() => {
  const count = useSignal(0);

  return (
    <button onClick$={() => count.value++}>
      Increment {count.value}
    </button>
  );
});
```
</CodeSandbox>

The example above demonstrates how useSignal() can be employed in a counter component to monitor the count. When the count.value property is modified, the component automatically updates. This can be observed in the button click handler in the example, where altering the property triggers the update.

> **Note**
> In situations where a component requires multiple signals, managing each signal as an independent state may not be desirable. In such cases, it is recommended to use `useStore()` instead.

> **Note**
> To ensure proper reactivity, it is important to maintain a reference to the reactive object rather than just its `.value` property. For instance, if you execute `let { value } = useSignal(0)` and then mutate `value`, it will not cause updates in components that depend on the property. Make sure to keep a reference to the reactive object itself.

## `useStore()`

`useStore()` works similarly to `useSignal()`, but it accepts an object as its initial value. A store can be thought of as a multi-value signal or an object composed of several signals.

To create a reactive object, use the `useStore(initialStateObject)` function, (aka hook). This hook takes an initial object and returns a reactive object.  Alternatively, `userStore(() => initialStateObject)` can be used to create a reactive object lazily.

> **Note**
> To ensure proper reactivity, it is important to maintain a reference to the reactive object rather than just its properties. For instance, if you execute `let { count } = useStore({ count: 0 })` and then mutate `count`, it will not cause updates in components that depend on the property. Make sure to keep a reference to the reactive object itself.

<CodeSandbox src="/src/routes/demo/state/counter-store/index.tsx" style={{ height: '6em' }} >
```tsx {4} /state/ /count/#a
import { component$, useStore } from '@builder.io/qwik';

export default component$(() => {
  const state = useStore({ count: 0 });

  return (
    <>
      <button onClick$={() => state.count++}>Increment</button>
      <div>Count: {state.count}</div>
    </>
  );
});
```
</CodeSandbox>

The example above demonstrates how `useStore()` can be implemented in a counter component to monitor the count. By using useStore(), the component can efficiently manage a single or multiple reactive properties as part of a single reactive object.

### Recursive values

By default, [`useStore()`](#usesignal) tracks only the `top-level` properties in your store. This means that, in order for an update to be registered, you must modify values at the top-level property.

<CodeSandbox src="/src/routes/demo/state/counter-store-no-track/index.tsx" style={{ height: '10em' }}>
```tsx
import { component$, useStore } from '@builder.io/qwik';

export default component$(() => {
  const store = useStore({
    nested: { fields: { are: 'not tracked' } },
  });

  return (
    <>
      <p>{store.nested.fields.are}</p>
      <button onClick$={() => (store.nested.fields.are = 'tracked')}>
        Clicking me does not work
      </button>
      <br />
      <button onClick$={() => (store.nested = { fields: { are: 'tracked' } })}>
        Click me works
      </button>
    </>
  );
});
```
</CodeSandbox>

The example above demonstrates how the default tracking strategy does not track changes to nested properties. To make the above example work, we would have to update the top-level `nested` field like so:

```ts
// `nested` is a top-level property that is an object itself, and it will be replaced with a new object
store.nested = { fields: { are: 'tracked' } };
```

While tracking top-level properties is the default behavior and suits most use cases, there might be instances where tracking changes to nested properties is required. In such cases, pass a second argument to `useStore(initialStateObject, { deep: true })` to enable recursion for tracking all the nested values in the store.

> **Note**
> There is no recursion `depth limit` when passing `{ deep: true }`. That being said, it is recommended to use this option only when necessary, as tracking `extremely deep` nested properties can have performance implications.

<CodeSandbox src="/src/routes/demo/state/counter-store-deep/index.tsx" style={{ height: '10em' }}>
```tsx
import { component$, useStore } from '@builder.io/qwik';

export default component$(() => {
  const store = useStore(
    {
      nested: { fields: { are: 'not tracked' } },
    },
    { deep: true } // warning: no recursion `depth limit`
  );

  return (
    <>
      <p>{store.nested.fields.are}</p>
      <button onClick$={() => (store.nested.fields.are = 'tracked')}>
        Clicking me works because store is deep watched
      </button>
      <br />
      <button onClick$={() => (store.nested = { fields: { are: 'tracked' } })}>
        Click me still works
      </button>
    </>
  );
});
```
</CodeSandbox>

Passing the `{ deep: true }` ensures that the component will update as expected.

> **Note**
> This will also track individual values inside of arrays!. Use with caution.

## Computed state

The computed state is derived from the existing state.

In Qwik there are two ways to create computed values, each with a different use case (in order of preference):

1. `useComputed$()`: `useComputed$()` is the preferred way of creating computed values. Use it when the computed value can be derived synchronously purely from the source state (current application state). For example, creating a lowercase version of a string or combining first and last name into a full name.
2. [`useResource$()`](/docs/(qwik)/components/resource/index.mdx): `useResource$()` is used when the computed value is asynchronous or the state comes from outside of the application. For example, fetching the current weather (external state) based on a current location (application internal state).

The way to think about the above is that they observe the existing state, and when the state changes the computed value is recomputed. The result is a newly computed value which is a signal returned from `useComputed$()` or `useResource$()`.

In addition to the two ways of creating computed values described above, there is also a lower-level ([`useTask$()`](/docs/(qwik)/components/tasks/index.mdx#usetask) and [`useVisibleTask$()`](/docs/components/tasks/#usevisibletask)) way of modifying/creating state as a result of input change. This way does not produce a new signal, but rather modifies the existing state or produces a side effect.:

### `useComputed$()`

Use `useComputed$` to create a computed value that can be derived synchronously from the existing application state.

<CodeSandbox src="/src/routes/demo/state/computed/index.tsx" style={{ height: '8em' }}>
```tsx {5} /useComputed$/
import { component$, useComputed$, useSignal } from '@builder.io/qwik';

export default component$(() => {
  const name = useSignal('Qwik');
  const capitalizedName = useComputed$(() => name.value.toUpperCase());

  return (
    <>
      <input type="text" bind:value={name} />
      <div>Name: {name.value}</div>
      <div>Capitalized name: {capitalizedName.value}</div>
    </>
  );
});
```
</CodeSandbox>

> **NOTE** Because `useComputed$()` is synchronous it is not necessary to explicitly track the input signals.

### `useResource$()`

Use `useResource$()` to create a computed value that is derived asynchronously or requires an external state (such as talking to a REST endpoint.) The hook is called when the component is mounted (and when the tracked values change.) The `useResource$` hook is meant to be used with the `<Resource />`. The `<Resource />` component is a convenient way to render the resource state, such as loaded, resolved, or rejected.

> **Note:** The important thing to understand about `useResource$` is that it executes on the initial component render (just like `useTask$`.) Often time it is desirable to start fetching the data on the server as part of the initial HTTP request before the component is rendered. Fetching data as part of SSR is a more common and preferred way of loading data and is done through [`routeLoader$`](/docs/(qwikcity)/route-loader/index.mdx) API instead. `useResource$` is more of a low-level API that is useful when you want to fetch data on in the browser.
>
> Just like all the `use-` hooks, it must be called within the context of [`component$()`](/docs/(qwik)/components/overview/index.mdx#component), and all the [hook rules apply](/docs/(qwik)/components/tasks/index.mdx).
>
> In many ways `useResource$` is similar to `useTask$` The big differences are:
>
> - `useResource$` allows you to return a "value".
> - `useResource$` does not block rendering while the resource is being resolved.
>
> See [`routeLoader$`](/docs/(qwikcity)/route-loader/index.mdx) for fetching data early as part of initial HTTP request.


<CodeSandbox src="/src/routes/demo/state/resource/index.tsx" style={{ height: '8em' }}>
```tsx {11} /useResource$/
import {
  component$,
  Resource,
  useResource$,
  useSignal,
} from '@builder.io/qwik';

export default component$(() => {
  const prNumber = useSignal('3576');

  const prTitle = useResource$(async ({ track }) => {
    track(() => prNumber.value); // Requires explicit tracking of inputs
    const response = await fetch(
      `https://api.github.com/repos/BuilderIO/qwik/pulls/${prNumber.value}`
    );
    const data = await response.json();
    return (data.title || data.message || 'Error') as string;
  });

  return (
    <>
      <input type="number" bind:value={prNumber} />
      <h1>
        PR#{prNumber}:
        <Resource
          value={prTitle}
          onPending={() => <>Loading...</>}
          onResolved={(title) => <>{title}</>}
        />
      </h1>
    </>
  );
});
```
</CodeSandbox>

While it is possible to use `useResource$()` without `<Resource>` component, it is provided for convenience. The `<Resource>` component automatically shows a fallback content while the resource is being computed.

> **NOTE**: During SSR the `<Resource>` component will pause rendering until the resource is resolved. This way the SSR will not render with the loading indicator.


**Advanced example**

A more complete example of fetching data with `AbortController`, `track` and `cleanup`. This example will fetch a list of jokes based on the query typed by the user,
automatically reacting to changes in the query, including aborting requests that are currently pending.

<CodeSandbox src="/src/routes/demo/state/resource-joke/index.tsx" style={{ height: '40em' }}>
```tsx {11} /useResource$/
import {
  component$,
  useResource$,
  Resource,
  useSignal,
} from '@builder.io/qwik';

export default component$(() => {
  const query = useSignal('busy');
  const jokes = useResource$<{ value: string }[]>(
    async ({ track, cleanup }) => {
      track(() => query.value);
      // A good practice is to use `AbortController` to abort the fetching of data if
      // new request comes in. We create a new `AbortController` and register a `cleanup`
      // function which is called when this function re-runs.
      const controller = new AbortController();
      cleanup(() => controller.abort());

      if (query.value.length < 3) {
        return [];
      }

      const url = new URL('https://api.chucknorris.io/jokes/search');
      url.searchParams.set('query', query.value);

      const resp = await fetch(url, { signal: controller.signal });
      const json = (await resp.json()) as { result: { value: string }[] };

      return json.result;
    }
  );

  return (
    <>
      Query: <input bind:value={query} />
      <button>search</button>
      <Resource
        value={jokes}
        onPending={() => <>loading...</>}
        onResolved={(jokes) => (
          <ul>
            {jokes.map((joke) => (
              <li>{joke.value}</li>
            ))}
          </ul>
        )}
      />
    </>
  );
});
```
</CodeSandbox>

As we see in the example above, `useResource$()` returns a `ResourceReturn<T>` object that works like a reactive promise, containing the data and the resource state.

The state `resource.loading` can be one of the following:

- `false` - the data is not yet available.
- `true` - the data is available. (Either resolved or rejected.)

The callback passed to [`useResource$()`](/docs/(qwik)/components/resource/index.mdx) runs right after the [`useTask$()`](/docs/(qwik)/components/tasks/index.mdx#usetask) callbacks complete. Please refer to the [Lifecycle](../tasks/index.mdx#lifecycle) section for more details.

### `<Resource />`

`<Resource />` is a component meant to be used with the `useResource$()` that renders different content depending on if the resource is pending, resolved, or rejected.

```tsx
<Resource
  value={weatherResource}
  onPending={() => <div>Loading...</div>}
  onRejected={() => <div>Failed to load weather</div>}
  onResolved={(weather) => {
    return <div>Temperature: {weather.temp}</div>;
  }}
/>
```

It is worth noting that `<Resource />` is not required when using `useResource$()`. It is just a convenient way to render the resource state.


This example shows how `useResource$` is used to perform a fetch call to the [agify.io](https://agify.io/) API. This will guess a person's age based on the name typed by the user, and will update whenever the user types in the name input.

<CodeSandbox src="/src/routes/demo/state/resource-agify/index.tsx" style={{ height: '8em' }}>
```tsx {11} /useResource$/
import {
  component$,
  useSignal,
  useResource$,
  Resource,
} from '@builder.io/qwik';

export default component$(() => {
  const name = useSignal<string>();

  const ageResource = useResource$<{
    name: string;
    age: number;
    count: number;
  }>(async ({ track, cleanup }) => {
    track(() => name.value);
    const abortController = new AbortController();
    cleanup(() => abortController.abort('cleanup'));
    const res = await fetch(`https://api.agify.io?name=${name.value}`, {
      signal: abortController.signal,
    });
    return res.json();
  });

  return (
    <div>
      <div>Enter your name, and I'll guess your age!</div>
      <input
        onInput$={(e: Event) =>
          (name.value = (e.target as HTMLInputElement).value)
        }
      />
      <Resource
        value={ageResource}
        onPending={() => <div>Loading...</div>}
        onRejected={() => <div>Failed to person data</div>}
        onResolved={(ageGuess) => {
          return (
            <div>
              {name.value && (
                <>
                  {ageGuess.name} {ageGuess.age} years
                </>
              )}
            </div>
          );
        }}
      />
    </div>
  );
});
```
</CodeSandbox>

## Passing state

One of the nice features of Qwik is that the state can be passed to other components. Writing to the store will then only re-render the components which read from the store only.

There are two ways to pass state to other components:

1. pass state to child component explicitly using props,
2. or pass state implicitly through context.

### Using props

The simplest way to pass the state to other components is to pass it through props.

<CodeSandbox src="/src/routes/demo/state/passing-props/index.tsx" style={{ height: '6em' }}>
```tsx {9} /userData=/
import { component$, useStore } from '@builder.io/qwik';

export default component$(() => {
  const userData = useStore({ count: 0 });
  return <Child userData={userData} />;
});

interface ChildProps {
  userData: { count: number };
}
export const Child = component$<ChildProps>(({ userData }) => {
  return (
    <>
      <button onClick$={() => userData.count++}>Increment</button>
      <div>Count: {userData.count}</div>
    </>
  );
});
```
</CodeSandbox>

### Using context

The context API is a way to pass state to components without having to pass it through props (i.e.: avoids prop drilling issues). Automatically, all the descendant components in the tree can access a reference to the state with read/write access to it.

Check the [context API](../context/index.mdx) for more information.

<CodeSandbox src="/src/routes/demo/state/passing-context/index.tsx" style={{ height: '6em' }}>
```tsx /userData/ /export const CTX = createContextId<{ count: number }>('stuff');/ /useContextProvider(CTX, userData);/ /const userData = useContext(CTX);/
import {
  component$,
  createContextId,
  useContext,
  useContextProvider,
  useStore,
} from '@builder.io/qwik';

// Declare a context ID
export const CTX = createContextId<{ count: number }>('stuff');

export default component$(() => {
  const userData = useStore({ count: 0 });

  // Provide the store to the context under the context ID
  useContextProvider(CTX, userData);

  return <Child />;
});

export const Child = component$(() => {
  const userData = useContext(CTX);
  return (
    <>
      <button onClick$={() => userData.count++}>Increment</button>
      <div>Count: {userData.count}</div>
    </>
  );
});
```
</CodeSandbox>

## `noSerialize()`

Qwik ensures that all application state is always serializable. This is important to ensure that Qwik applications have a [resumability](/docs/(qwik)/concepts/resumable/index.mdx) property. At times it is necessary to store data that can't be serialized. For example a reference to a third-party library such as [Monaco editor](https://microsoft.github.io/monaco-editor/). In such a situation use `noSerialize()` to mark the value as non-serializable.

If a value is marked as non-serializable then that value will not survive serialization events such as resuming the application on the client from server SSR. In such a situation the value will be set to `undefined` and it is up to the developer to re-initialize the value on the client.

<CodeSandbox src="/src/routes/demo/state/no-serialize/index.tsx" style={{ height: '8em' }}>
```tsx /noSerialize/
import {
  component$,
  useStore,
  noSerialize,
  useVisibleTask$,
} from '@builder.io/qwik';
import Monaco from './monaco';

export default component$(() => {
  const store = useStore<{ monacoInstance: Monaco | undefined }>({
    // Don't initialize on server
    monacoInstance: undefined,
  });

  useVisibleTask$(() => {
    // Monaco is not serializable, so we can't serialize it as part of SSR
    // We can however instantiate it on the client after the component is visible
    setTimeout(() => (store.monacoInstance = noSerialize(new Monaco())), 1000);
  });
  return <div>{store.monacoInstance ? 'Monaco is loaded' : 'loading...'}</div>;
});
```
</CodeSandbox>
